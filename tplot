#!/usr/bin/perl -w

use Term::ANSIColor; 
use Getopt::Std;
use Pod::Usage;
use List::Util qw[min max];

$0 =~/.*\/(.*)/;

my %options= ();
getopts("b:r:f:s:y:l:h",\%options);


########################################################
#  Preparation                                         #
########################################################

# Exit if -h is typed or -r is not used
if (defined $options{"h"} || not( defined $options{r})) {

   pod2usage(-verbose=>2, -noperldoc=>1);
}


# Get row numbers
my @col_nums   = split(",", $options{r});
my $num_series = scalar @col_nums;


# Record legends;
my @legends = ();

if (defined $options{l}) {

    for ( split(",", $options{l}) ){

        push @legends, $_;
    }
}

# Screen matrix size 
my $width = 100; 
my $height = 13;


# Handling size option -s 
if (defined $options{s}) {

    my @items = split(",", $options{s});

    if (@items == 1) { 
        $height = $items[0];

    } elsif ( @items == 2) {
        if ($items[0] ne "") {
            $height = $items[0];
            $width = $items[1]; 

        } else {
            $width = $items[1];
        }
    }
}


########################################################
#   Read Data                                          #
########################################################
my @matrix = ();
my @labels = ();
my $global_max = -1e32; 
my $global_min = 1e32;
my $global_abs_max;

for (<>) {
    chomp $_;

    my @items = split(" ", $_);

    # Read Labelss
    if (defined $options{b}) {
        push @labels, $items[$options{b}-1];
    }

    for (my $i=0;$i<$num_series; $i++ ) {

        my $value = $items[ $col_nums[$i] - 1 ];

        push @{$matrix[$i]}, $value;

        if ($value > $global_max) { $global_max = $value }; 
        if ($value < $global_min) { $global_min = $value };
    }
}

my $num_obs = scalar @{$matrix[0]};


# Handling y-axis option -y to determin final min,max 
if (defined $options{y}) {

   my @items = split(",", $options{y});

   if (@items == 1) { 
       $global_min = $items[0];

   } elsif (@items == 2) { 
       if ($items[0] ne "") { 
           $global_min = $items[0];
           $global_max = $items[1]; 

       } else {
           $global_max = $items[1];
       }
   }
}

$global_abs_max = max(abs($global_min), abs($global_max));



# Determine y axis format 
my $indent = " "x9;

my $ytick_label_max;
my $ytick_label_min;

if (defined $options{f}) {
    $ytick_label_max = formatLabel($options{f}, $global_max); 
    $ytick_label_min = formatLabel($options{f}, $global_min);

} else {
    my $format = "";

    if ($global_abs_max <= 1) {
        $format = "p";

    } elsif ($global_abs_max <= 1e5 ) {
        $format = "d";

    } elsif ($global_abs_max <= 1e6 ) {
        $format = "k";

    } elsif ($global_abs_max <= 1e9 ) {
        $format = "m";
    }

    $ytick_label_max = formatLabel($format, $global_max); 
    $ytick_label_min = formatLabel($format, $global_min);
}



# Fill up screen matrix 
my @screen   = ();
my @crossing = ();

for (my $s=0; $s < $num_series; $s++) {

    my $last_r_index;
    my $last_c_index;

    for (my $i=0; $i<$num_obs; $i++) {

        next if ( $matrix[$s][$i] > $global_max or $matrix[$s][$i] < $global_min ); 

        # Fill the point
        my $r_index = getGridIndex($matrix[$s][$i], $global_min, $global_max, $height);
        my $c_index = getGridIndex($i, 0, $num_obs-1, $width);

        if (defined $screen[$r_index][$c_index]) {

            if ($s > $screen[$r_index][$c_index]) {

                $screen[$r_index][$c_index]   = $s;
                $crossing[$r_index][$c_index] = $s;
            }

        } else {
            $screen[$r_index][$c_index] = $s;
        }


        #Fill between points
        if ($i > 0){

            my $c_w = $last_c_index - $c_index;
            my $r_w = $last_r_index - $r_index;

            for (my $mv_c_indx = $last_c_index+1; $mv_c_indx < $c_index; $mv_c_indx++) {

                my $new_r_indx = int($last_r_index + ($mv_c_indx - $last_c_index)/ $c_w * $r_w + 0.5);

                if (defined $screen[$new_r_indx][$mv_c_indx]) {

                    if ($s > $screen[$new_r_indx][$mv_c_indx]) {

                        $screen[$new_r_indx][$mv_c_indx] = $s;
                    }

                } else {
                    $screen[$new_r_indx][$mv_c_indx] = $s;
                }
            }
        }


        # Record last point indeces
        $last_r_index = $r_index;
        $last_c_index = $c_index;
    }
}

# Zero line
my $zero_index = getGridIndex(0, $global_min, $global_max, $height);




########################################################
#   Plot (print)                                       #
########################################################
print "\n";

my @colors = ('bright_blue', 'bright_red', 'yellow', 'bright_cyan', 'bright_green');


# Print Legends
my $leg_start_point;

if (@legends > $num_series ) {
    $leg_start_point = $width - ( length(join("", @legends[0..$num_series-1])) + 5 * $num_series) + 1;

} else {
    $leg_start_point = $width - ( length(join("", @legends)) + 5 * $num_series + ($num_series - @legends)) + 1;
}

if ( $leg_start_point <0) { $leg_start_point = 0 };

print $indent." "." "x ($leg_start_point);

for ( 1 .. $num_series) {

    print color $colors[$_-1];

    if (defined $legends[$_-1]) {
        print "o - $legends[$_-1] ";

    } else {
        print "o - $_ ";
    }
}
print "\n";


# Print main plot
for (my $r = $height-1; $r>=0; $r--) {

    # Ytick mark label 
    print color "white";

    if ( $r == 0 ) {
        print $ytick_label_min." ";

    } elsif ( $r == $height - 1) {
        print $ytick_label_max." ";

    } elsif ( $r == $zero_index) {
        print " "x8 . "0 ";
    }
    else {
        print $indent." ";
    }


    # print the row
    for (my $c=0; $c < $width; $c++) {

        if (defined $screen[$r][$c]) {

            my $dot_series_num = $screen[$r][$c];

            if ( defined $crossing[$r][$c] ) {
                print color $colors[$dot_series_num];
                print "x";

            } else {
                print color $colors[$dot_series_num];
                print "o";
            }

        } elsif ( $r == $zero_index and $c == 0 ) {
            print color "white";
            print "+";
        } elsif ( $r == $zero_index and $c%2 == 0) {
            print color "bright_black";
            print "-";
        } elsif ( $c == 0 ) {
            print color "white";
            print "|";
        } else {
            print " ";
        }
    }

    # next row
    print "\n";
}

print color "white";


# Print x-axis and tick marks
my $xaxis = "-" x $width;
my $xtick_label = " " x $width;

my $step = max(1, int($num_obs / 10) );

for ($i=0; $i<$num_obs; $i=$i+$step) {
    my $index = getGridIndex($i, 0, $num_obs-1, $width);
    substr($xaxis, $index , 1) = "|";

    if (defined $options{b}) {
        my $lab = $labels[$i];
        my $len = length($lab);
        substr($xtick_label, $index , $len) = $lab;
    } else {
        substr($xtick_label, $index , 4) = sprintf("%-4d", $i);
    }
}

print $indent." ". $xaxis."\n";
print $indent." ". $xtick_label."\n";



########################################################
#   SUBROUTINES                                        #
########################################################
 
sub formatLabel {
    my ($format, $value) = @_;

    if ( $format eq "m" ) {
        $value = $value / 1e6; 
        return(sprintf("%8.1fM", $value));

    } elsif ( $format eq "k" ) {
        $value = $value / 1000; 
        return(sprintf("%8.1fk", $value));

    } elsif ( $format eq "p" ) {
        $value = $value * 100; 
        return(sprintf("%8.2f", $value)."%");

    } elsif ( $format eq "d" ) {
        $value = int($value);
        return(sprintf("%9s", commify($value)));

    } else {
        return(sprintf("%9.2e", $value));
    }
}


sub getGridIndex {

    my ($value, $min, $max, $num_grid) = @_;

    my $half_buck_size  = ($max - $min)/ ($num_grid - 1) / 2;

    my $index = int(  ($value - $min + $half_buck_size ) / ($max - $min) * ($num_grid-1) ); 

    return( $index );
}


sub getRefValue {

    my ($index, $min, $max, $num_grid) = @_;

    my $value = $index / ($num_grid - 1) * ($max - $min) + $min;

    return( $value );
}


sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}



############################
### Usage Page         #####
############################

__END__

=head1 NAME

tplot - A simple terminal plotting tool

=head1 SYNOPSIS

tplot -r col1[,col2,..] [-b col] [-s hieght,width] [-y min,max] [-f format] [-l legend1, legend2, ..] [-h] [file]


=head1 OPTIONS

The following options are supported:

=over 12

=item B<-r> col1[,col2,..]

List the column numbers that are to be included in the plot.

=item B<-b> col

Column to be used for labels.

=item B<-s> height,width

The size of the plotting area. Default height is 15 and default width is 100.

=item B<-y> min,max

Set min and max of the y axis.

=item B<-f> format

Format of the y-axis label. If not selected, it will be decided based on the max absolute value of the input. "m" for millions. "p" for percentage. "k" for thousands.

=item B<-l> legend1, legend2,...

Legends for each series. If not selected, numbers will be used.

=item B<-h>

Print this help message.


=back

=cut

